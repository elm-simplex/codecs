[{"name":"Orchard.Codecs","comment":" This module provides the public api for serializing and deserializing almost any Elm data type via a custom binary protocol.\n\n@docs codecsFor\n\n","unions":[],"aliases":[],"values":[{"name":"codecsFor","comment":" Generate Binary encoder/decoder pairs for any type, using a densely packed binary protocol. The decoder from this pair is guaranteed to decode values generated by the encoder, but no other guarantees are provided, regarding protocol stability or otherwise.\n","type":"a -> { encoder : a -> Bytes.Encode.Encoder, decoder : Bytes.Decode.Decoder a }"}],"binops":[]},{"name":"Orchard.Wire","comment":" Orchard.Wire contains all the built-in codecs used by Wire.\n\n@docs andMapDecode, andThenDecode, decodeArray, decodeBool, decodeBytes, decodeChar, decodeDict, decodeFloat, decodeFloat64, decodeInt, decodeInt64, decodeList, decodeMaybe, decodeNever, decodeOrder, decodePair, decodeResult, decodeSet, decodeString, decodeTriple, decodeUnit, encodeArray, encodeBool, encodeBytes, encodeChar, encodeDict, encodeFloat, encodeFloat64, encodeInt, encodeInt64, encodeList, encodeMaybe, encodeNever, encodeOrder, encodePair, encodeResult, encodeSequence, encodeSequenceWithoutLength, encodeSet, encodeString, encodeTriple, encodeUnit, endianness, failDecode, failEncode, identityFloatToInt, intDivBy, signedToUnsigned, succeedDecode, unsignedToSigned, Decoder, Encoder\n\n","unions":[],"aliases":[{"name":"Decoder","comment":" ","args":["a"],"type":"Bytes.Decode.Decoder a"},{"name":"Encoder","comment":" ","args":[],"type":"Bytes.Encode.Encoder"}],"values":[{"name":"andMapDecode","comment":" ","type":"Orchard.Wire.Decoder a -> Orchard.Wire.Decoder (a -> b) -> Orchard.Wire.Decoder b"},{"name":"andThenDecode","comment":" ","type":"(a -> Orchard.Wire.Decoder b) -> Orchard.Wire.Decoder a -> Orchard.Wire.Decoder b"},{"name":"decodeArray","comment":" ","type":"Orchard.Wire.Decoder a -> Orchard.Wire.Decoder (Array.Array a)"},{"name":"decodeBool","comment":" ","type":"Orchard.Wire.Decoder Basics.Bool"},{"name":"decodeBytes","comment":" ","type":"Orchard.Wire.Decoder Bytes.Bytes"},{"name":"decodeChar","comment":" ","type":"Orchard.Wire.Decoder Char.Char"},{"name":"decodeDict","comment":" ","type":"Orchard.Wire.Decoder comparable -> Orchard.Wire.Decoder value -> Orchard.Wire.Decoder (Dict.Dict comparable value)"},{"name":"decodeFloat","comment":" ","type":"Orchard.Wire.Decoder Basics.Float"},{"name":"decodeFloat64","comment":" ","type":"Orchard.Wire.Decoder Basics.Float"},{"name":"decodeInt","comment":" ","type":"Orchard.Wire.Decoder Basics.Int"},{"name":"decodeInt64","comment":" ","type":"Orchard.Wire.Decoder Basics.Int"},{"name":"decodeList","comment":" ","type":"Orchard.Wire.Decoder a -> Orchard.Wire.Decoder (List.List a)"},{"name":"decodeMaybe","comment":" ","type":"Orchard.Wire.Decoder a -> Orchard.Wire.Decoder (Maybe.Maybe a)"},{"name":"decodeNever","comment":" ","type":"Orchard.Wire.Decoder Basics.Never"},{"name":"decodeOrder","comment":" ","type":"Orchard.Wire.Decoder Basics.Order"},{"name":"decodePair","comment":" ","type":"Orchard.Wire.Decoder a -> Orchard.Wire.Decoder b -> Orchard.Wire.Decoder ( a, b )"},{"name":"decodeResult","comment":" ","type":"Orchard.Wire.Decoder err -> Orchard.Wire.Decoder val -> Orchard.Wire.Decoder (Result.Result err val)"},{"name":"decodeSet","comment":" ","type":"Orchard.Wire.Decoder comparable -> Orchard.Wire.Decoder (Set.Set comparable)"},{"name":"decodeString","comment":" ","type":"Orchard.Wire.Decoder String.String"},{"name":"decodeTriple","comment":" ","type":"Orchard.Wire.Decoder a -> Orchard.Wire.Decoder b -> Orchard.Wire.Decoder c -> Orchard.Wire.Decoder ( a, b, c )"},{"name":"decodeUnit","comment":" ","type":"Orchard.Wire.Decoder ()"},{"name":"encodeArray","comment":" ","type":"(a -> Orchard.Wire.Encoder) -> Array.Array a -> Orchard.Wire.Encoder"},{"name":"encodeBool","comment":" ","type":"Basics.Bool -> Orchard.Wire.Encoder"},{"name":"encodeBytes","comment":" ","type":"Bytes.Bytes -> Orchard.Wire.Encoder"},{"name":"encodeChar","comment":" ","type":"Char.Char -> Orchard.Wire.Encoder"},{"name":"encodeDict","comment":" ","type":"(key -> Orchard.Wire.Encoder) -> (value -> Orchard.Wire.Encoder) -> Dict.Dict key value -> Orchard.Wire.Encoder"},{"name":"encodeFloat","comment":" ","type":"Basics.Float -> Orchard.Wire.Encoder"},{"name":"encodeFloat64","comment":" ","type":"Basics.Float -> Orchard.Wire.Encoder"},{"name":"encodeInt","comment":" ","type":"Basics.Int -> Orchard.Wire.Encoder"},{"name":"encodeInt64","comment":" ","type":"Basics.Int -> Orchard.Wire.Encoder"},{"name":"encodeList","comment":" ","type":"(a -> Orchard.Wire.Encoder) -> List.List a -> Orchard.Wire.Encoder"},{"name":"encodeMaybe","comment":" ","type":"(a -> Orchard.Wire.Encoder) -> Maybe.Maybe a -> Orchard.Wire.Encoder"},{"name":"encodeNever","comment":" ","type":"Basics.Never -> Orchard.Wire.Encoder"},{"name":"encodeOrder","comment":" ","type":"Basics.Order -> Orchard.Wire.Encoder"},{"name":"encodePair","comment":" ","type":"(a -> Orchard.Wire.Encoder) -> (b -> Orchard.Wire.Encoder) -> ( a, b ) -> Orchard.Wire.Encoder"},{"name":"encodeResult","comment":" ","type":"(err -> Orchard.Wire.Encoder) -> (val -> Orchard.Wire.Encoder) -> Result.Result err val -> Orchard.Wire.Encoder"},{"name":"encodeSequence","comment":" ","type":"List.List Orchard.Wire.Encoder -> Orchard.Wire.Encoder"},{"name":"encodeSequenceWithoutLength","comment":" ","type":"List.List Orchard.Wire.Encoder -> Orchard.Wire.Encoder"},{"name":"encodeSet","comment":" ","type":"(value -> Orchard.Wire.Encoder) -> Set.Set value -> Orchard.Wire.Encoder"},{"name":"encodeString","comment":" ","type":"String.String -> Orchard.Wire.Encoder"},{"name":"encodeTriple","comment":" ","type":"(a -> Orchard.Wire.Encoder) -> (b -> Orchard.Wire.Encoder) -> (c -> Orchard.Wire.Encoder) -> ( a, b, c ) -> Orchard.Wire.Encoder"},{"name":"encodeUnit","comment":" ","type":"() -> Orchard.Wire.Encoder"},{"name":"endianness","comment":" ","type":"Bytes.Endianness"},{"name":"failDecode","comment":" ","type":"Orchard.Wire.Decoder a"},{"name":"failEncode","comment":" ","type":"a -> Orchard.Wire.Encoder"},{"name":"identityFloatToInt","comment":" `floor` is one of few functions that turn integer floats in js into typed integers in Elm, e.g. the Float `3` into the Int `3`.\n","type":"Basics.Float -> Basics.Int"},{"name":"intDivBy","comment":" ","type":"Basics.Int -> Basics.Int -> Basics.Int"},{"name":"signedToUnsigned","comment":" ","type":"Basics.Int -> Basics.Int"},{"name":"succeedDecode","comment":" ","type":"a -> Orchard.Wire.Decoder a"},{"name":"unsignedToSigned","comment":" ","type":"Basics.Int -> Basics.Int"}],"binops":[]}]